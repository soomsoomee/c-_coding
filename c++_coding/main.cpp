// 주석
// 설명 역할, 코드로 인식되지 않는다.

int main()
{
	// 자료형 (크기 단위, byte) -> 정수와 실수는 메모리를 활용하는 방식이 다르다.
	// 실수 표현방식은 정밀도에 의존한다. 따라서 double 자료형이 float보다 더 아래의 소수점까지 정확하게 표현이 가능하다.  
	// 4와 4.0의 비트 값이 다름. 따라서 섞여있을 때 무엇을 기준으로 할지 정해야함. -> 형변환 과정이 추가됨. 

	// 정수형: char(1), short(2), int(4), long(4), long long(8)
	// 실수형: float(4), double(8) -> 부동소수점(지수파트, 가수파트로 나눠쓴다.) 
	// 이진법의 소수점 하나는 2**-1 (=1/2), 2**-2 (=1/4) .... 이런식임. 
	// 근사치로 계산되기 때문에 소수를 계산할 때 1이 나와야할 것이 0.999999999 이런식으로 나올 수도 있음. 조건식이 원하는대로 작동하지 않을 수 있음. 

	
	// 1byte = 8bit -> 1bit는 가장 작은 단위로 각각은 자료가 있는지 없는지만 나타낸다. 
	// 1KB = 1024byte, 1MB = 1024KB, 1GB = 1024MB, 1TB = 1024GB 
	

	// 4byte 크기의 정수 타입 변수 i가 데이터로 저장된다.
	int i = 0;

	// 8bit으로는 총 2**8 (=256) 가지의 경우를 표현할 수 있다. 따라서 1byte로 0 이상 정수만 표현하면 0부터 255까지 나타낼 수 있다. 
	// 0이상의 정수만 표현하는 경우 unsigned 추가. c는 0부터 255까지 나타낼 수 있다.
	unsigned char c = 0;

	// 대입 연산자
	// c = 256는 저장되지 않음. 0으로 들어온다. 아홉번째 1이 들어오지 않기 때문이다. 
	// c = -1 넣으면 255로 보인다. 에러가 나지 않음. 
	c = 0;
	c = 255;

	// char = signed char : 음수, 양수 모두 표현 가능
	// 1byte로 -128 ~ -1,  0 ~ 127 표현 가능 (블록이 8개 있으면 제일 앞에 블록이 0인 경우를 양수, 1인 경우를 음수에 대응시킴. 이 비트를 MSB;most significant bit라고 한다.)
	// msb가 0일 때는 양수, 1일 때는 음수를 표현한다.
	// 컴퓨터가 음수를 표현하는 방식: 뺄셈은 음수의 합이라고 본다. 따라서 10이랑 더해서 0이 되는 상태가 -10이라고 본다. 
	// 01111111 = 127이고, 이것과 더해서 0이 되는 수가 -127이다. 따라서 10000001이 -127이 된다. 가장 앞에 올라가는 수는 자릿수 초과되니까 고려되지 않음. 
	// 마찬가지로 00000001과 더해서 0이 되는 11111111이 -1이다. c1=255라고 하면 -1이 저장된다. 
	// c = 255, c1 = 255일 때 두 변수의 비트 상태는 동일하다. 동일한 메모리 공간에 똑같이 데이터가 채워져있더라도 관점(=자료형)에 따라 값이 다르게 해석된다. 
	// 음수 빨리 찾는 법: 2의 보수법 -> 0은 1로, 1은 0으로 바꾸고 1만 더한다. (그냥 반대로 더하면 다 1이 나오니까 1개를 더 올려주는 것)
	char c1 = 0;

	// 2byte는 2**16 경우의 수를 나타낼 수 있다. 비트가 16개 이므로. (-3만 ~ 3만)
	// 적절한 만큼의 메모리를 가지도록 자료형을 설정하는 것이 중요하다. 

	// 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자.
	float f = 10.2415f + float(20);
	

	return 0;
}