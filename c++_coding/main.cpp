// 주석
// 설명 역할, 코드로 인식되지 않는다.

int main()
{
	// 자료형 (크기 단위, byte) -> 정수와 실수는 메모리를 활용하는 방식이 다르다.
	// 실수 표현방식은 정밀도에 의존한다. 따라서 double 자료형이 float보다 더 아래의 소수점까지 정확하게 표현이 가능하다.  
	// 4와 4.0의 비트 값이 다름. 따라서 섞여있을 때 무엇을 기준으로 할지 정해야함. -> 형변환 과정이 추가됨. 

	// 정수형: char(1), short(2), int(4), long(4), long long(8)
	// 실수형: float(4), double(8) -> 부동소수점(지수파트, 가수파트로 나눠쓴다.) 	

	int i = 0;

	// 8bit으로는 총 2**8 (=256) 가지의 경우를 표현할 수 있다. 따라서 1byte로 0 이상 정수만 표현하면 0부터 255까지 나타낼 수 있다. 
	// 0이상의 정수만 표현하는 경우 unsigned 추가. c는 0부터 255까지 나타낼 수 있다.
	unsigned char c = 0;

	// 대입 연산자
	// c = 256는 저장되지 않음. 0으로 들어온다. 아홉번째 1이 들어오지 않기 때문이다. 
	// c = -1 넣으면 255로 보인다. 에러가 나지 않음. 
	c = 0;
	c = 255;

	// char = signed char : 음수, 양수 모두 표현 가능
	// 1byte로 -128 ~ -1,  0 ~ 127 표현 가능 (블록이 8개 있으면 제일 앞에 블록이 0인 경우를 양수, 1인 경우를 음수에 대응시킴. 이 비트를 MSB;most significant bit라고 한다.)
	// msb가 0일 때는 양수, 1일 때는 음수를 표현한다.
	// 컴퓨터가 음수를 표현하는 방식: 뺄셈은 음수의 합이라고 본다. 따라서 10이랑 더해서 0이 되는 상태가 -10이라고 본다. 
	// 마찬가지로 00000001과 더해서 0이 되는 11111111이 -1이다. c1=255라고 하면 -1이 저장된다. 
	// c = 255, c1 = 255일 때 두 변수의 비트 상태는 동일하다. 동일한 메모리 공간에 똑같이 데이터가 채워져있더라도 관점(=자료형)에 따라 값이 다르게 해석된다. 

	char c1 = 0;

	// 2byte는 2**16 경우의 수를 나타낼 수 있다. 비트가 16개 이므로. (-3만 ~ 3만)
	// 적절한 만큼의 메모리를 가지도록 자료형을 설정하는 것이 중요하다. 

	// 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자.
	float f = 10.2415f + float(20);

	// 실수를 상수로 적을 경우 소수점 뒤에 f를 붙이면 float 자료형으로, f를 붙이지 않으면 double 자료형으로 간주한다.
	// 0.1f, 0.1;
	
	// 연산자(operater)
	// 대입 연산자, =
	// 산술 연산자
	// +, -, *, /, %(모듈러스, 나머지)
	// ++, -- (증감연산자) -> 한 단계 증가/감소 -> 꼭 1로 변화하는 것은 아님. 대입 안해도 메모리 값 자체가 변함. 
	int data = 10 + 10;
	data += 20;

	// 나누기: 피연산자가 정수인지, 실수인지에 따라 다름.
	// 실수 나눗셈에서는 나머지가 존재하지 않음. 나머지 연산은 피연산자가 정수인 경우만 사용 가능.

	data = 10 / 3; // 3
	data = 10 % 3; // 1
	// 10. % 3.은 컴파일 에러 발생

	// int data이므로 3.이 3으로 변환됨.(경고 메시지) -> 명확하게 정수로 변환하기.
	data = (int)( 10. / 3.);

	data = 0;
	// 전위, 후위 상관 없는 경우 전위로 쓰는 것이 좋다. 
	++data; // (전위)
	data++; // (후위)
	data--;

	int a;
	data = 0;
	a = 10;
	data = a++; // 후위 연산자로 사용하는 경우 연산자 순위는 가장 마지막이다. data=10. data에 a를 넣고 증가. 전위라면 data=11. 

	// 논리 연산자
	// !(역, 반대로), &&(곱, AND), ||(합, OR)
	// 참(true), 거짓(false)
	// 참 : 0이 아닌 값, 주로 1 (10을 줘도 true인데 true를 1로 본다.)
	// 거짓: 0

	true;
	false;
	int truefalse = true; // truefalse = 1
	
	// bool 자료형: 0 or 1 (1byte), 참과 거짓만 다루는 자료형. 
	bool truefalse = false;
	bool IsTrue = 100; // IsTrue = 1

	IsTrue = true;
	IsTrue = !IsTrue; // IsTrue = false

	int iTrue = 100;
	iTrue = !iTrue; // iTrue = 0
	
	iTrue = 100 && 200; // iTrue => true => 1
	iTrue = 0 && 200; // iTrue => false => 0

	iTrue = 0 || 100; // iTrue => true => 1


	// 비교 연산자
	// ==, !=, <, >, <=, >=
	// 참, 거짓


	//구문
	// if, else
	data = 0;
	if (0 && 200) // false => 아래 구문이 수행됨. 
	{
		data = 100;
	}

	if (data == 100)
	{
		// if가 참인 경우 수행
	}
	else if (data == 101)
	{
		// if가 거짓인 경우 수행 + 조건 검사
	}
	else
	{

	};

	// switch case
	
	// 삼항연산자
	// :?

	return 0;
}